from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import time
import csv
import os
import logging
from datetime import datetime
# SIMPLIFICADO: Solo importar sistema de log CSV
from viajes_log import registrar_viaje_fallido as log_viaje_fallido

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GMSalidaAutomation:
    def __init__(self, driver, datos_viaje=None):
        self.driver = driver
        self.wait = WebDriverWait(driver, 20)
        self.datos_viaje = datos_viaje or {}
        
    def obtener_sucursal_por_determinante(self, clave_determinante):
        """Obtiene la sucursal correspondiente a la clave determinante"""
        csv_path = 'modules/clave_ruta_base.csv'
        
        # Mapeo de base_origen a valores del select (solo las que usamos)
        mapeo_sucursales = {
            'HERMOSILLO': '6',    # BASE HERMOSILLO
            'OBREGON': '7'        # BASE OBREGON
        }
        
        try:
            if os.path.exists(csv_path):
                with open(csv_path, newline='', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        if row['determinante'] == str(clave_determinante):
                            base_origen = row['base_origen'].upper()
                            valor_select = mapeo_sucursales.get(base_origen, '1')  # Default: TODAS
                            logger.info(f"‚úÖ Determinante {clave_determinante} -> Base: {base_origen} -> Valor: {valor_select}")
                            return valor_select
            else:
                logger.warning(f"‚ö†Ô∏è No se encontr√≥ archivo: {csv_path}")
                
        except Exception as e:
            logger.error(f"‚ùå Error al obtener sucursal: {e}")
            
        return '1'  # Default: TODAS
    
    def calcular_fecha_anterior(self, fecha_str):
        """Calcula el d√≠a anterior a la fecha dada"""
        try:
            from datetime import datetime, timedelta
            fecha_obj = datetime.strptime(fecha_str, '%d/%m/%Y')
            fecha_anterior = fecha_obj - timedelta(days=1)
            return fecha_anterior.strftime('%d/%m/%Y')
        except Exception as e:
            logger.error(f"‚ùå Error al calcular fecha anterior: {e}")
            return fecha_str
    
    def llenar_fecha_salida_robusto(self, campo_id, fecha_valor):
        """
        FUNCI√ìN MEJORADA: Llena fecha de salida con validaci√≥n anti-1000
        
        Args:
            campo_id: ID del campo de fecha
            fecha_valor: Fecha en formato DD/MM/YYYY
            
        Returns:
            bool: True si se insert√≥ correctamente, False si fall√≥
        """
        try:
            logger.info(f"üéØ Llenando fecha ROBUSTA en {campo_id}: {fecha_valor}")
            
            # Intentar hasta 3 veces si hay problemas
            for intento in range(3):
                logger.info(f"üîÑ Intento {intento + 1}/3 para insertar fecha")
                
                # Paso 1: Localizar y hacer clic en el campo
                campo = self.wait.until(EC.element_to_be_clickable((By.ID, campo_id)))
                
                # Paso 2: LIMPIEZA AGRESIVA
                logger.info("üßπ Limpieza agresiva del campo...")
                campo.click()
                time.sleep(0.3)
                
                # M√∫ltiples m√©todos de limpieza
                campo.send_keys(Keys.CONTROL + "a")  # Seleccionar todo
                time.sleep(0.1)
                campo.send_keys(Keys.DELETE)         # Borrar selecci√≥n
                time.sleep(0.1)
                campo.clear()                        # M√©todo clear adicional
                time.sleep(0.1)
                
                # Limpieza adicional caracter por caracter
                for _ in range(15):  # Eliminar hasta 15 caracteres residuales
                    campo.send_keys(Keys.BACKSPACE)
                    time.sleep(0.05)
                
                # Paso 3: Verificar que est√° limpio
                valor_actual = campo.get_attribute("value")
                logger.info(f"üìã Campo despu√©s de limpieza: '{valor_actual}'")
                
                if valor_actual and len(valor_actual) > 0:
                    logger.warning(f"‚ö†Ô∏è Campo no est√° completamente limpio: '{valor_actual}'")
                    # Una limpieza final
                    campo.send_keys(Keys.HOME)
                    time.sleep(0.1)
                    for _ in range(20):
                        campo.send_keys(Keys.DELETE)
                        time.sleep(0.02)
                
                # Paso 4: INSERTAR FECHA LENTAMENTE
                logger.info(f"‚å®Ô∏è Insertando fecha: {fecha_valor}")
                time.sleep(0.5)  # Pausa antes de escribir
                
                # Escribir car√°cter por car√°cter para evitar problemas
                for i, char in enumerate(fecha_valor):
                    campo.send_keys(char)
                    time.sleep(0.08)  # Pausa entre caracteres
                
                # Paso 5: VALIDACI√ìN INMEDIATA
                time.sleep(0.5)  # Esperar que se procese
                valor_final = campo.get_attribute("value")
                logger.info(f"‚úÖ Valor final en campo: '{valor_final}'")
                
                # Verificar que no tiene el problema del 1000
                if "1000" in valor_final:
                    logger.error(f"üö® ERROR DETECTADO: Fecha con '1000': '{valor_final}'")
                    logger.error("üîÑ Reintentando limpieza e inserci√≥n...")
                    continue
                    
                # Verificar longitud razonable (DD/MM/YYYY = 10 caracteres + posible hora)
                if len(valor_final) > 20:
                    logger.error(f"üö® ERROR DETECTADO: Fecha muy larga: '{valor_final}' ({len(valor_final)} chars)")
                    logger.error("üîÑ Reintentando limpieza e inserci√≥n...")
                    continue
                
                # Verificar que contiene la fecha esperada
                if fecha_valor.replace("/", "") not in valor_final.replace("/", "").replace(" ", ""):
                    logger.error(f"üö® ERROR DETECTADO: Fecha no coincide")
                    logger.error(f"   Esperado: {fecha_valor}")
                    logger.error(f"   Obtenido: {valor_final}")
                    logger.error("üîÑ Reintentando...")
                    continue
                
                # Si llegamos aqu√≠, la fecha est√° correcta
                logger.info(f"‚úÖ Fecha insertada correctamente: '{valor_final}'")
                
                # Confirmar con ENTER
                campo.send_keys(Keys.ENTER)
                time.sleep(0.3)
                
                return True
                
            # Si llegamos aqu√≠, fallaron todos los intentos
            logger.error(f"‚ùå ERROR CR√çTICO: No se pudo insertar fecha despu√©s de 3 intentos")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Error en llenar_fecha_salida_robusto: {e}")
            return False
    
    def detectar_operador_ocupado(self):
        """
        Detecta el BTN_OK de operador ocupado
        Retorna: True si se detect√≥, False si no
        """
        try:
            logger.info("üîç Verificando si apareci√≥ BTN_OK de operador ocupado...")
            
            # Buscar espec√≠ficamente el bot√≥n BTN_OK
            try:
                btn_ok = self.driver.find_element(By.ID, "BTN_OK")
                
                if btn_ok.is_displayed() and btn_ok.is_enabled():
                    logger.warning("üö® BTN_OK DETECTADO - OPERADOR OCUPADO")
                    return True
                    
            except NoSuchElementException:
                # No hay BTN_OK, todo bien
                logger.info("‚úÖ No se detect√≥ BTN_OK - proceso normal")
                return False
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error al detectar BTN_OK: {e}")
            return False
    
    def manejar_operador_ocupado(self):
        """
        FUNCI√ìN SIMPLIFICADA: Maneja el error de operador ocupado
        SOLO registra en log CSV
        """
        try:
            logger.warning("üö® MANEJANDO ERROR DE OPERADOR OCUPADO")
            
            # Paso 1: Hacer clic en BTN_OK para cerrar el error
            try:
                btn_ok = self.wait.until(EC.element_to_be_clickable((By.ID, "BTN_OK")))
                self.driver.execute_script("arguments[0].click();", btn_ok)
                time.sleep(2)
                logger.info("‚úÖ BTN_OK clickeado")
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en BTN_OK: {e}")
            
            # Paso 2: Preparar datos para registro
            prefactura = self.datos_viaje.get('prefactura', 'DESCONOCIDA')
            fecha_viaje = self.datos_viaje.get('fecha', '')
            placa_tractor = self.datos_viaje.get('placa_tractor', 'DESCONOCIDA')
            placa_remolque = self.datos_viaje.get('placa_remolque', 'DESCONOCIDA')
            determinante = self.datos_viaje.get('clave_determinante', 'DESCONOCIDO')
            importe = self.datos_viaje.get('importe', '')
            cliente_codigo = self.datos_viaje.get('cliente_codigo', '')
            
            motivo = f"Operador ocupado - Tractor {placa_tractor} no disponible"
            
            # SIMPLIFICADO: Registrar SOLO en log CSV
            try:
                exito_csv = log_viaje_fallido(
                    prefactura=prefactura,
                    motivo_fallo=motivo,
                    determinante=determinante,
                    fecha_viaje=fecha_viaje,
                    placa_tractor=placa_tractor,
                    placa_remolque=placa_remolque,
                    importe=importe,
                    cliente_codigo=cliente_codigo
                )
                
                if exito_csv:
                    logger.info("‚úÖ Operador ocupado registrado en log CSV")
                    logger.info("üö® OPERADOR OCUPADO REGISTRADO:")
                    logger.info(f"   üìã Prefactura: {prefactura}")
                    logger.info(f"   üöõ Placa Tractor: {placa_tractor}")
                    logger.info(f"   üìä Estatus en CSV: FALLIDO")
                    logger.info(f"   üîç Motivo: {motivo}")
                    logger.info("   üîß ACCI√ìN: Revisar disponibilidad de operador")
                    logger.info("üîÑ MySQL se actualizar√° autom√°ticamente desde CSV")
                else:
                    logger.error("‚ùå Error registrando en log CSV")
                    
            except Exception as e:
                logger.error(f"‚ùå Error registrando en log CSV: {e}")
            
            # Paso 3: Cerrar navegador
            try:
                logger.warning("üö® CERRANDO NAVEGADOR por operador ocupado")
                self.driver.quit()
                logger.info("‚úÖ Navegador cerrado exitosamente")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error cerrando navegador: {e}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error general manejando operador ocupado: {e}")
            return False
    
    def configurar_filtros_busqueda(self):
        """Configura los filtros de b√∫squeda con los checkboxes espec√≠ficos"""
        try:
            logger.info("‚öôÔ∏è Configurando filtros de b√∫squeda...")
            
            # Paso 1: Abrir configuraci√≥n de B√∫squeda General
            busqueda_link = self.wait.until(EC.element_to_be_clickable((By.ID, "LINK_BUSQUEDAGENERAL")))
            busqueda_link.click()
            time.sleep(2)
            logger.info("‚úÖ Configuraci√≥n de B√∫squeda General abierta")
            
            # Paso 2: DESMARCAR filtros que NO queremos
            filtros_a_desmarcar = ["_1_TABLE_BUSQUEDAGENERAL_1", "_2_TABLE_BUSQUEDAGENERAL_1"]
            
            for filtro_id in filtros_a_desmarcar:
                try:
                    checkbox = self.driver.find_element(By.ID, filtro_id)
                    if checkbox.is_selected():
                        self.driver.execute_script("arguments[0].click();", checkbox)
                        logger.info(f"   ‚úÖ DESMARCADO: {filtro_id}")
                        time.sleep(0.3)
                    else:
                        logger.info(f"   ‚ÑπÔ∏è Ya desmarcado: {filtro_id}")
                except Exception as e:
                    logger.warning(f"   ‚ö†Ô∏è No se pudo desmarcar {filtro_id}: {e}")
            
            # Paso 3: MARCAR filtros que S√ç queremos
            filtros_a_marcar = ["_5_TABLE_BUSQUEDAGENERAL_1", "_7_TABLE_BUSQUEDAGENERAL_1", "_8_TABLE_BUSQUEDAGENERAL_1"]
            
            for filtro_id in filtros_a_marcar:
                try:
                    checkbox = self.driver.find_element(By.ID, filtro_id)
                    if not checkbox.is_selected():
                        self.driver.execute_script("arguments[0].click();", checkbox)
                        logger.info(f"   ‚úÖ MARCADO: {filtro_id}")
                        time.sleep(0.3)
                    else:
                        logger.info(f"   ‚ÑπÔ∏è Ya marcado: {filtro_id}")
                except Exception as e:
                    logger.warning(f"   ‚ö†Ô∏è No se pudo marcar {filtro_id}: {e}")
            
            # Paso 4: Aplicar configuraci√≥n
            try:
                seleccionar_btn = self.wait.until(EC.element_to_be_clickable((By.ID, "BTN_SELECCIONARBUSQUEDAGENERAL")))
                seleccionar_btn.click()
                time.sleep(2)
                logger.info("‚úÖ Filtros aplicados con 'Seleccionar'")
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en 'Seleccionar': {e}")
                return False
            
            logger.info("‚úÖ Configuraci√≥n de filtros completada")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error al configurar filtros de b√∫squeda: {e}")
            return False
    
    def ajustar_fecha_desde(self, fecha_viaje):
        """Ajusta la fecha 'desde' al d√≠a anterior del viaje"""
        try:
            fecha_desde = self.calcular_fecha_anterior(fecha_viaje)
            
            # USAR FUNCI√ìN ROBUSTA PARA FECHA DESDE
            exito = self.llenar_fecha_salida_robusto("EDT_DESDE", fecha_desde)
            
            if exito:
                logger.info(f"‚úÖ Fecha 'desde' ajustada a: {fecha_desde}")
                return True
            else:
                logger.error(f"‚ùå Error al ajustar fecha desde con funci√≥n robusta")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error al ajustar fecha desde: {e}")
            return False
    
    def seleccionar_sucursal(self, clave_determinante):
        """Selecciona la sucursal correcta basada en la clave determinante"""
        try:
            valor_sucursal = self.obtener_sucursal_por_determinante(clave_determinante)
            
            select_sucursal = Select(self.wait.until(EC.element_to_be_clickable((By.ID, "COMBO_CATSUCURSALES"))))
            select_sucursal.select_by_value(valor_sucursal)
            time.sleep(0.5)
            
            # Obtener texto de la opci√≥n seleccionada
            opcion_seleccionada = select_sucursal.first_selected_option.text
            logger.info(f"‚úÖ Sucursal seleccionada: {opcion_seleccionada}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error al seleccionar sucursal: {e}")
            return False
    
    def buscar_viaje(self, prefactura):
        """Busca el viaje por prefactura"""
        try:
            # Llenar campo de b√∫squeda con prefactura
            campo_busqueda = self.wait.until(EC.element_to_be_clickable((By.ID, "EDT_BUSCARVIAJES")))
            campo_busqueda.click()
            campo_busqueda.clear()
            campo_busqueda.send_keys(str(prefactura))
            logger.info(f"‚úÖ Prefactura '{prefactura}' ingresada en b√∫squeda")
            
            # Hacer clic en Aplicar
            try:
                aplicar_btn = self.wait.until(EC.element_to_be_clickable((By.ID, "BTN_APLICAR")))
                aplicar_btn.click()
                time.sleep(3)
                logger.info("‚úÖ Filtros aplicados")
                    
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en Aplicar: {e}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error al buscar viaje: {e}")
            return False
    
    def seleccionar_viaje_de_tabla(self):
        """FUNCI√ìN CON DEBUG: Selecciona el primer viaje de la tabla despu√©s del filtrado"""
        try:
            logger.info("üîç Buscando viajes en la tabla...")
            
            # Esperar m√°s tiempo tras aplicar filtros
            time.sleep(3)
            
            # DEBUG: Buscar elementos de viajes con m√∫ltiples selectores
            logger.info("üîç DEBUG: Probando diferentes selectores...")
            
            # Selector 1: TABLE_PROVIAJES
            elementos_proviajes = self.driver.find_elements(By.XPATH, "//div[contains(@id, 'TABLE_PROVIAJES')]")
            logger.info(f"üìä Selector TABLE_PROVIAJES encontr√≥: {len(elementos_proviajes)} elementos")
            
            # Selector 2: Filas de tabla gen√©ricas
            filas_tabla = self.driver.find_elements(By.XPATH, "//table//tr[td]")
            logger.info(f"üìä Selector filas de tabla encontr√≥: {len(filas_tabla)} elementos")
            
            # Selector 3: Buscar elementos con texto "WALMART" o "WAL MART"
            elementos_walmart = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'WAL MART') or contains(text(), 'WALMART')]")
            logger.info(f"üìä Elementos con WALMART encontrados: {len(elementos_walmart)} elementos")
            
            # DEBUG: Mostrar algunos IDs de elementos encontrados
            if elementos_proviajes:
                logger.info("üîç IDs de elementos TABLE_PROVIAJES:")
                for i, elem in enumerate(elementos_proviajes[:3]):  # Mostrar m√°ximo 3
                    try:
                        elem_id = elem.get_attribute('id')
                        elem_text = elem.text[:50] if elem.text else "Sin texto"
                        logger.info(f"   {i+1}: ID='{elem_id}' Texto='{elem_text}'")
                    except:
                        logger.info(f"   {i+1}: Error obteniendo info del elemento")
            
            # Decidir qu√© selector usar - PRIORIZAR WALMART
            elementos_a_usar = None
            selector_usado = ""
            
            if elementos_walmart:
                # PRIORIDAD 1: Usar elementos con texto WALMART (los viajes reales)
                elementos_a_usar = elementos_walmart
                selector_usado = "WALMART text"
            elif elementos_proviajes and len(elementos_proviajes) <= 20:
                # PRIORIDAD 2: Solo usar TABLE_PROVIAJES si hay pocos elementos (evitar headers)
                elementos_a_usar = elementos_proviajes
                selector_usado = "TABLE_PROVIAJES"
            elif filas_tabla and len(filas_tabla) <= 10:
                # PRIORIDAD 3: Filas de tabla solo si hay muy pocas
                elementos_a_usar = filas_tabla
                selector_usado = "filas de tabla"
            else:
                logger.error("‚ùå No se encontraron elementos v√°lidos para seleccionar")
                logger.error(f"   - WALMART: {len(elementos_walmart)} (MEJOR OPCI√ìN)")
                logger.error(f"   - TABLE_PROVIAJES: {len(elementos_proviajes)} (muchos elementos, incluye headers)")
                logger.error(f"   - Filas tabla: {len(filas_tabla)} (muchas filas)")
                return False
            
            logger.info(f"‚úÖ Usando selector: {selector_usado} con {len(elementos_a_usar)} elementos")
            
            # Hacer clic en el primer elemento
            primer_elemento = elementos_a_usar[0]
            try:
                # Intentar hacer scroll al elemento primero
                self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'auto', block: 'center'});", primer_elemento)
                time.sleep(0.5)
                
                # Hacer clic
                self.driver.execute_script("arguments[0].click();", primer_elemento)
                logger.info(f"‚úÖ Primer elemento seleccionado autom√°ticamente usando {selector_usado}")
                
                # Esperar m√°s tiempo para que GM procese la selecci√≥n
                time.sleep(4)
                
                # Verificar que apareci√≥ el link "Salida"
                try:
                    salida_check = WebDriverWait(self.driver, 10).until(
                        EC.presence_of_element_located((By.LINK_TEXT, "Salida"))
                    )
                    if salida_check.is_displayed():
                        logger.info("‚úÖ Viaje seleccionado correctamente - Link 'Salida' disponible")
                        return True
                    else:
                        logger.error("‚ùå Link 'Salida' existe pero no es visible")
                        return False
                        
                except Exception as e:
                    logger.error(f"‚ùå Link 'Salida' no apareci√≥ despu√©s de 10 segundos: {e}")
                    
                    # DEBUG: Mostrar qu√© links est√°n disponibles
                    try:
                        todos_links = self.driver.find_elements(By.TAG_NAME, "a")
                        links_visibles = [link.text.strip() for link in todos_links 
                                        if link.is_displayed() and link.text.strip()]
                        logger.info(f"üîç Links disponibles actualmente: {links_visibles[:10]}")
                    except:
                        pass
                    
                    return False
                    
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en el elemento: {e}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error general al seleccionar viaje de tabla: {e}")
            return False
    
    def procesar_salida_viaje(self):
        """Proceso espec√≠fico de salida del viaje CON DETECCI√ìN DE OPERADOR OCUPADO Y FECHA ROBUSTA"""
        try:
            logger.info("üöõ Iniciando proceso de SALIDA del viaje")
            
            # Obtener fecha del viaje
            fecha_viaje = self.datos_viaje.get('fecha', '')
            if not fecha_viaje:
                logger.error("‚ùå No se encontr√≥ fecha del viaje")
                return False
            
            # Paso 1: Hacer clic en el link "Salida"
            try:
                salida_link = self.wait.until(EC.element_to_be_clickable((By.LINK_TEXT, "Salida")))
                self.driver.execute_script("arguments[0].click();", salida_link)
                time.sleep(1.5)
                logger.info("‚úÖ Link 'Salida' clickeado")
                
                # Verificar inmediatamente si hay error de operador ocupado
                if self.detectar_operador_ocupado():
                    self.manejar_operador_ocupado()
                    return "OPERADOR_OCUPADO"
                    
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en 'Salida': {e}")
                return False
            
            # Paso 2: Llenar fecha de salida CON FUNCI√ìN ROBUSTA
            try:
                logger.info("üìÖ Llenando fecha de salida con m√©todo ROBUSTO...")
                exito_fecha = self.llenar_fecha_salida_robusto("EDT_SALIDA", fecha_viaje)
                
                if not exito_fecha:
                    logger.error("‚ùå ERROR CR√çTICO: No se pudo insertar fecha de salida despu√©s de intentos robustos")
                    return False
                
                logger.info(f"‚úÖ Fecha de salida '{fecha_viaje}' insertada con √©xito")
                
                # Verificar si hay error despu√©s de insertar fecha
                time.sleep(1)
                if self.detectar_operador_ocupado():
                    self.manejar_operador_ocupado()
                    return "OPERADOR_OCUPADO"
                    
            except Exception as e:
                logger.error(f"‚ùå Error al insertar fecha de salida: {e}")
                return False
            
            # Paso 3: Seleccionar status "EN RUTA"
            try:
                status_select = Select(self.wait.until(EC.element_to_be_clickable((By.ID, "COMBO_CATESTATUSVIAJE"))))
                status_select.select_by_value("2")  # EN RUTA
                time.sleep(0.5)
                logger.info("‚úÖ Status 'EN RUTA' seleccionado")
                
                # Verificar si hay error despu√©s de cambiar status
                if self.detectar_operador_ocupado():
                    self.manejar_operador_ocupado()
                    return "OPERADOR_OCUPADO"
                    
            except Exception as e:
                logger.error(f"‚ùå Error al seleccionar status EN RUTA: {e}")
                return False
            
            # Paso 4: Hacer clic en "Aceptar" (PUNTO CR√çTICO donde aparece BTN_OK)
            try:
                aceptar_btn = self.wait.until(EC.element_to_be_clickable((By.ID, "BTN_ACEPTAR")))
                self.driver.execute_script("arguments[0].click();", aceptar_btn)
                time.sleep(3)  # Tiempo extra para que aparezca BTN_OK si hay error
                logger.info("‚úÖ Bot√≥n 'Aceptar' clickeado")
                
                # VERIFICACI√ìN CR√çTICA: aqu√≠ es donde aparece BTN_OK si operador est√° ocupado
                if self.detectar_operador_ocupado():
                    self.manejar_operador_ocupado()
                    return "OPERADOR_OCUPADO"
                    
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en 'Aceptar': {e}")
                return False
            
            # Paso 5: Responder "No" al env√≠o de correo (solo si no hubo error)
            try:
                no_btn = self.wait.until(EC.element_to_be_clickable((By.ID, "BTN_NO")))
                self.driver.execute_script("arguments[0].click();", no_btn)
                time.sleep(2)
                logger.info("‚úÖ Bot√≥n 'No' clickeado - Proceso de salida completado")
                    
            except Exception as e:
                logger.error(f"‚ùå Error al hacer clic en 'No': {e}")
                return False
            
            logger.info("‚úÖ Proceso de SALIDA completado exitosamente")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error en proceso de salida: {e}")
            return False
    
    def procesar_salida_completo(self, configurar_filtros=True):
        """Proceso principal para buscar el viaje y procesarle la salida"""
        try:
            logger.info("üöÄ Iniciando proceso completo de salida del viaje")
            
            # Extraer datos necesarios
            fecha_viaje = self.datos_viaje.get('fecha', '')
            prefactura = self.datos_viaje.get('prefactura', '')
            clave_determinante = self.datos_viaje.get('clave_determinante', '')
            
            if not all([fecha_viaje, prefactura, clave_determinante]):
                logger.error("‚ùå Faltan datos necesarios para procesar salida")
                return False
            
            logger.info(f"üìã Procesando: Prefactura={prefactura}, Fecha={fecha_viaje}, Determinante={clave_determinante}")
            
            # Configurar filtros MEJORADO
            if configurar_filtros:
                logger.info("‚öôÔ∏è Configurando filtros de b√∫squeda...")
                if not self.configurar_filtros_busqueda():
                    logger.warning("‚ö†Ô∏è No se pudieron configurar los filtros - continuando de todas formas")
                    # Continuar de todas formas, los filtros no son cr√≠ticos
            
            # Ajustar fecha desde CON FUNCI√ìN ROBUSTA
            if not self.ajustar_fecha_desde(fecha_viaje):
                logger.warning("‚ö†Ô∏è Error ajustando fecha - continuando")
                # No es cr√≠tico, continuar
            
            # Seleccionar sucursal
            if not self.seleccionar_sucursal(clave_determinante):
                logger.warning("‚ö†Ô∏è Error seleccionando sucursal - continuando")
                # No es cr√≠tico, continuar
            
            # Buscar viaje
            if not self.buscar_viaje(prefactura):
                logger.error("‚ùå Error cr√≠tico buscando viaje")
                return False
            
            # Seleccionar viaje de la tabla (SIN pausas manuales)
            if not self.seleccionar_viaje_de_tabla():
                logger.error("‚ùå Error cr√≠tico seleccionando viaje autom√°ticamente")
                return False
            
            # Procesar salida del viaje
            resultado = self.procesar_salida_viaje()
            
            if resultado == "OPERADOR_OCUPADO":
                logger.warning("üö® OPERADOR OCUPADO: Error registrado en CSV, navegador cerrado")
                logger.info("üîÑ MySQL se actualizar√° autom√°ticamente desde CSV")
                return "OPERADOR_OCUPADO"
            elif resultado:
                logger.info("‚úÖ Proceso completo de salida completado exitosamente")
                return True
            else:
                logger.error("‚ùå Error en proceso de salida")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Error general en procesar_salida_completo: {e}")
            return False

# Funci√≥n principal para ser llamada desde otros m√≥dulos
def procesar_salida_viaje(driver, datos_viaje=None, configurar_filtros=True):
    """
    FUNCI√ìN SIMPLIFICADA: Procesar la salida del viaje CON REGISTRO SOLO EN CSV
    Retorna:
    - True: √âxito
    - False: Error que debe detener el proceso
    - "OPERADOR_OCUPADO": Operador ocupado, error registrado en CSV, continuar con siguiente viaje
    """
    try:
        automation = GMSalidaAutomation(driver, datos_viaje)
        resultado = automation.procesar_salida_completo(configurar_filtros)
        
        # Registrar el resultado en logs
        prefactura = datos_viaje.get('prefactura', 'DESCONOCIDA') if datos_viaje else 'DESCONOCIDA'
        
        if resultado == "OPERADOR_OCUPADO":
            logger.warning(f"üö® VIAJE {prefactura}: Operador ocupado - registrado en CSV")
            logger.info("üîÑ MySQL se sincronizar√° autom√°ticamente desde CSV")
        elif resultado:
            logger.info(f"‚úÖ VIAJE {prefactura} PROCESADO: Salida completada exitosamente")
        else:
            logger.error(f"‚ùå VIAJE {prefactura} FALL√ì: Error en proceso de salida")
            
        return resultado
        
    except Exception as e:
        logger.error(f"‚ùå Error en procesar_salida_viaje: {e}")
        return False